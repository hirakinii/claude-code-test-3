

# **機能仕様書：仕様書作成支援アプリ**

| ドキュメント名 | 機能仕様書：仕様書作成支援アプリ |
| :---- | :---- |
| バージョン | 1.0 |
| 作成日 | 2025年11月18日 |
| 作成者 | Gemini 2.5 Pro Deep Research |
| レビューア | 平木俊幸 |

**改訂履歴**

| バージョン | 日付 | 変更内容 | 作成者 |
| :---- | :---- | :---- | :---- |
| 1.0 | 2025年11月18日 | 新規作成 | Gemini 2.5 Pro Deep Research |

---

## **1\. このアプリの目的と範囲**

### **1.1. アプリケーションの目的**

本アプリケーション「仕様書作成支援アプリ」の第一目的は、組織内における調達仕様書やソフトウェア仕様書の作成、管理、および共有のプロセスを**構造化し、効率化すること**にあります。

提供されたユーザーストーリー分析 1 および要件定義書 2 によると、従来の仕様書作成プロセスには、入力漏れの発生、バージョン管理の煩雑さ、作業の長時間化によるデータ消失リスクといった課題が存在すると想定されます。

本アプリは、これらの課題に対し、以下の手段を提供することによって、仕様書作成の品質と生産性を向上させることを目的とします。

* **構造化された入力:** 複雑な仕様書項目をステップ・バイ・ステップのウィザード形式で入力させます 1。  
* **入力漏れの防止:** 必須項目のバリデーションと視覚的なサマリー表示により、致命的な入力漏れを防ぎます 1。  
* **シームレスな作業継続:** 入力中のデータの自動保存と、作業再開時のシームレスな復元機能を提供します 2。  
* **柔軟なテンプレート:** 組織の業務プロセスに合わせて、仕様書の入力項目自体を定義・変更できる管理機能を提供します 1。

### **1.2. 中核的な提供価値：動的スキーマ管理（メタモデル・アーキテクチャ）**

本アプリケーションのアーキテクチャを決定づける中核的な価値は、**メタモデル・アーキテクチャ**の採用にあります 3。

これは、データモデルを以下の2つの層に明確に分離する設計です 3。

1. **インスタンス（データ）層:** 「仕様書作成者」がウィザードを通じて入力する、個々の仕様書の具体的な「値」（例：「件名：XXシステム開発」）を格納します。  
2. **スキーマ（定義）層:** 「仕様書管理者」が設定画面を通じて定義する、仕様書の「型」または「テンプレート」（例：「"件名" という入力項目が存在し、それは必須項目である」）を格納します。

このアーキテクチャは、本アプリが単なる「仕様書作成ツール」ではなく、\*\*「仕様書作成ツールの*定義*ツール」\*\*として機能することを可能にします。

ユーザーストーリー 1 では、管理者が「ステップ（カテゴリ）」や「入力項目」を自由に定義・変更できることが要求されています。従来の静的なデータベースカラム（例：specifications テーブルに subject カラムを設ける）では、この要件を実現するためにはデータベースのスキーマ変更とアプリケーションの再デプロイが必要となり、柔軟性が著しく損なわれます 3。

本設計では、アプリケーションロジックが「スキーマ層」を読み込んで動的にUI（ウィザード画面）を構築します 5。その結果、開発者のデプロイ作業を一切必要とせず、管理者が組織の業務プロセス（例：ソフトウェア開発用と物品購入用）に合わせて、入力フォーム自体を即座に変更できるという、**最大限の業務柔軟性**が実現されます。これが本アプリの最大の技術的価値です。

### **1.3. アプリケーションのスコープ**

#### **1.3.1. スコープ内 (In Scope)**

本アプリケーションが対象とする機能範囲は以下の通りです。

* **仕様書管理:** 自身がアクセス権を持つ仕様書の一覧表示、ステータス・バージョン管理 1。  
* **仕様書作成:** スキーマ定義に基づく動的なウィザードUIによる、ステップ・バイ・ステップの仕様書作成 1。  
* **仕様書レビュー:** 入力内容のサマリー表示、必須項目のバリデーション、クイック編集ナビゲーション 1。  
* **保存とバージョン管理:** 入力状態（必須項目の充足）に基づく、ドラフト保存（マイナーバージョン）と確定保存（メジャーバージョン）の分岐 2。  
* **データ保持:** ローカルストレージを利用した入力内容の自動保存および復元 2。  
* **エクスポート:** 参照・レビュー用の外部ファイル（PDF, Word, Markdown）生成 1。  
* **スキーマ管理:** 「仕様書管理者」によるウィザードのステップ、入力項目、データ型、必須設定のCRUD操作 1。

#### **1.3.2. スコープ外 (Out of Scope)**

以下の機能は、本仕様書の範囲外と定義されます。

* **リアルタイム共同編集:** 本アプリは、ローカルストレージへの自動保存 2 を前提とした単一ユーザーによる編集を想定しています。Googleドキュメントのような複数人による同時編集機能はスコープ外です。  
* **高度な承認ワークフロー:** 仕様書のステータス 6 は「編集中」「確認中」「保存済み」といったシンプルな状態管理に留まります。レビュー担当者のアサイン、承認・差し戻しのための複雑なワークフロー機能はスコープ外です。  
* **外部システム連携:** JIRA, GitHub, ERP, 契約管理システム等、他の業務システムとのAPI連携はスコープ外です。エクスポート機能 1 が、外部との手動によるデータ連携手段となります。

### **1.4. 対象ユーザーとロール**

本アプリケーションは、明確に分離された2つのユーザーロールを前提として設計されています 2。

* **仕様書作成者 (Creator):**  
  * **責務:** インスタンス層（データ）の入力。  
  * **主要機能:** ダッシュボード 6 での仕様書管理、ウィザード 7 を用いた仕様書の新規作成・編集、詳細画面 8 でのエクスポート。  
* **仕様書管理者 (Admin):**  
  * **責務:** スキーマ層（テンプレート）の定義・管理。  
  * **主要機能:** トップページの「設定」ボタン 6 からスキーマ設定画面 (G-04) にアクセスし、ウィザードのステップ (カテゴリ) と入力項目 (フィールド) を定義・変更する 1。  
  * **制約:** このロールを持つユーザーのみが「設定」ボタンにアクセス可能である必要があります（RBAC要件2）。

---

## **2\. 要件定義**

### **2.1. 要件定義の概要**

本アプリケーションのすべての機能、非機能、および画面に関する要件は、提供された分析資料に基づき定義されています。本機能仕様書は、これらの要件定義を正とし、その実現のための設計を記述するものです。

### **2.2. 要件定義書（参照）**

要件の完全なリスト（機能要件、非機能要件、画面要件を含む）は、以下のマスタードキュメントに記載されています。本仕様書（FSD）の以降のセクションは、下記ドキュメントの概要を提示するもの、または下記ドキュメントの要件を実現するための設計を記述するものです。

詳細な要件項目については、下記資料を**正**として参照してください。

* **\[資料\]** 仕様書作成支援アプリ\_要件定義書 2

### **2.3. 主要ユーザーストーリーの概要**

アプリケーションの主要な活動は、仕様書作成支援アプリ\_ユーザーストーリー分析 1 に基づき、以下のグループに分類されます。

* **【グループ1：仕様書管理（ダッシュボード）】:** ユーザーが自身の仕様書を一覧し、新規作成や編集を開始する活動。  
* **【グループ2：仕様書作成（ウィザード Steps 1-5）】:** 構造化されたウィザードに従い、仕様書の各項目を定義・入力する活動。  
* **【グループ3：レビュー、バリデーション、保存（ウィザード Step 6）】:** 入力内容を一覧し、入力漏れ（バリデーション）を確認し、バージョンを確定（保存）する活動。  
* **【グループ4：仕様書の利用（詳細・エクスポート）】:** 保存済みの仕様書を参照し、外部レビューのために PDF, Word, Markdown 形式で出力する活動。  
* **【グループ5：システム管理（スキーマ設定）】:** 管理者が、グループ2および3で使用される仕様書のテンプレート（スキーマ）自体を定義・変更する活動。  
* **【グループ6：非機能要件・ユーザビリティ】:** ユーザーストーリー分析 1 には、非機能要件もユーザーの具体的なペイン（苦痛）から導出されたストーリーとして定義されています。例えば、「自動保存」や「作業のシームレスな再開」は、「ブラウザのクラッシュ等で、長時間かけて入力した内容が失われることを防ぐため」という明確な理由に基づいています。これは、非機能要件が単なる技術的制約ではなく、ユーザー体験の核となる機能的価値を持つことを示しており、本FSDの第4部（非機能要件）および第6部（基本設計）において最優先事項として扱われます。

---

## **3\. 機能要件**

本セクションでは、仕様書作成支援アプリ\_要件定義書 2 に定義された主要な機能要件を、ユーザーストーリーのグループ 1 に沿って概説します。

### **3.1. 【グループ1】仕様書管理（ダッシュボード）**

トップページ (G-016) における仕様書の管理機能群。

* **3.1.1. 仕様書一覧表示:** ユーザーがアクセス権を持つ仕様書をテーブル形式（件名、ステータス、バージョン、最終更新日、操作）で表示します 2。  
* **3.1.2. ステータスの視覚的識別:** ステータス（例：「確認中」）は、識別しやすいよう色付きのバッジで表示されます 2。  
* **3.1.3. 新規仕様書の作成:** 「+ 新規作成」ボタン 6 をクリックすると、システムは内部的に新しい仕様書IDを採番し、ユーザーをウィザードのステップ1 (G-027) に直接リダイレクトします 2。  
* **3.1.4. 状態別のアクションボタン制御:** 一覧 6 の「操作」カラムに表示されるボタンは、仕様書のステータスに応じて動的に変更されます 2。  
  * ステータスが「保存済み」の場合: 「詳細」ボタンを表示します（G-03へ遷移）。  
  * ステータスが「保存済み」以外（例：「編集中」「確認中」）の場合: 「編集」ボタンを表示します（G-02へ遷移）。  
* **3.1.5. 設定画面へのナビゲーション:** 「設定」ボタン 6 をクリックすると、スキーマ設定画面 (G-04) へ遷移します。この操作は「仕様書管理者」ロールを持つユーザーにのみ許可されます 2。

### **3.2. 【グループ2】仕様書作成（ウィザード）**

ウィザード画面 (G-027) における仕様書の作成機能群。

* **3.2.1. ウィザードによる構造化入力:** 複雑な仕様書項目を、ステップ・バイ・ステップ（例：1. 基本情報, 2\. スコープ...）で入力します 1。  
* **3.2.2. ステップ間ナビゲーション:** フッターの「次へ」「前へ」ボタン、および画面上部のステップ進捗バー 7 のクリックにより、ステップ間を移動できます 2。  
* **3.2.3. 進捗の定量的表示:** ウィザード上部 7 に、各ステップの「(入力済み項目数 / 総項目数)」（例：「1. 基本情報 (0/3)」）をリアルタイムで表示します 2。  
* **3.2.4. 動的リスト項目管理（1対多）:**  
  * 「納品物」「受注者要件」「業務タスク」など、1対多の項目は「+...を追加」ボタンで動的に追加できます 2。  
  * **\[要件補足\]** ユーザーストーリー分析 1 には「追加・編集・*削除*したい」と明記されています。これは、誤って追加した項目をリストから削除するために論理的に必須の機能です。UIイメージ 7 には明示的に描画されていませんが、仕様書作成支援アプリ\_要件定義書 2 にも「動的リスト項目削除（論理的必須要件）」として定義されています。したがって、本FSDは、各動的入力ブロック（「納品物X」など）に「削除」ボタン（または「x」アイコン）を実装することを正式な要件として定義します。

### **3.3. 【グループ3】レビュー、バリデーション、保存**

ウィザードの最終ステップ (G-0210) における確認・保存機能群。

* **3.3.1. 最終確認サマリー表示:** ステップ1〜5で入力した全項目の内容を、読み取り専用のサマリーとして一覧表示します 2。  
* **3.3.2. 入力漏れの視覚的検知（バリデーション）:**  
  * サマリー表示時 10、スキーマ (G-04) で「必須」と定義された項目のうち、未入力の項目（例：「(未入力)」）は、背景色（例：薄赤色）で強調表示されます 2。  
* **3.3.3. 編集のためのクイックナビゲーション:** サマリー 10 の各セクション（例：「基本情報」）の横にある「編集」ボタンをクリックすると、対応するウィザードのステップ（例：ステップ1）に直接ジャンプ（遷移）できます 2。  
* **3.3.4. 保存処理とバージョン管理ロジック:** 「仕様書を保存する」ボタン 10 押下時のロジックは、必須項目の入力状態によって分岐します 2。  
  * **ドラフト保存（マイナーバージョン）:** スキーマで定義された「必須」項目のうち、1つ以上が未入力の場合。仕様書のバージョンはマイナーインクリメント（例: 1.0 $\\to$ 1.1、1.1 $\\to$ 1.2）され、ステータスは「編集中」または「確認中」に設定されます。  
  * **確定保存（メジャーバージョン）:** スキーマで定義された「必須」項目がすべて入力済みの場合。仕様書のバージョンはメジャーインクリメント（例: 1.0 $\\to$ 2.0、1.1 $\\to$ 2.0）され、ステータスは「保存済み」に設定されます。

### **3.4. 【グループ4】仕様書の利用（詳細・エクスポート）**

「保存済み」仕様書の詳細確認 (G-038) およびエクスポート機能群。

* **3.4.1. 仕様書詳細の参照:** 仕様書の主要なメタデータ（作成日、件名、バージョン、納品期限など）を一覧で確認できます 8。  
* **3.4.2. エクスポート機能（PDF, Word, Markdown）:** 詳細画面 8 から、仕様書を以下の形式でエクスポートできます。  
  * **PDF:** レイアウトを固定し、改変不可能な「正本」として、アプリのアカウントを持たない関係者（ベンダー、上長）にも正式に共有するために使用されます 1。  
  * **Word:** アプリ外で「変更履歴」や「コメント」機能を使ったレビュー（赤入れ）や共同編集を行うために使用されます 1。  
  * **Markdown:** 仕様書の変更履歴をGitなどのバージョン管理システムで、差分（Diff）として技術的に管理するために使用されます 1。

### **3.5. 【グループ5】システム管理（スキーマ設定）**

管理者向けの設定画面 (G-04) におけるテンプレート管理機能群。

* **3.5.1. カテゴリ（ステップ）の管理 (CRUD):** ウィザードのステップ（例：「1. 基本情報」）を自由に定義（追加・編集・削除）できます。また、UIには明示されていませんが、ステップの順序を並べ替える機能も論理的に必要とされます 2。  
* **3.5.2. 入力項目の管理 (CRUD):** 各カテゴリ内の入力項目（例：「件名」）を自由に定義（追加・編集・削除）できます。また、項目間の順序を並べ替える機能も必要とされます 2。  
* **3.5.3. データ型・必須設定:** 各入力項目に対し、データ型（テキスト, テキストエリア, ラジオボタン, チェックボックス, リスト, 日付等）および「必須」フラグ（バリデーションや保存ロジックで使用）を設定できます 2。  
* **3.5.4. スキーマのデフォルト復元:** 管理者が「デフォルトに戻す」ボタンをクリックし、確認ダイアログを経て、カスタマイズしたスキーマをシステム提供の初期状態にリセットできます 2。

---

## **4\. 非機能要件**

本セクションでは、仕様書作成支援アプリ\_要件定義書 2 の「全体・共通要件」で定義された非機能要件を概説します。これらの要件は、アプリケーションの品質とユーザー体験の根幹をなすものです。

### **4.1. ユーザビリティ**

* **4.1.1. UIコンポーネントの視認性担保:**  
  * **概要:** 「納品期限」のカレンダーアイコン 1 など、操作可能なUIコンポーネントは、背景色と明確に区別できる色（例：黒）で表示し、ユーザーが即座に認識・操作できるようにします。  
* **4.1.2. 新規作成時のUX最適化（ステップ0のスキップ）:**  
  * **概要:** トップページ 6 の「+ 新規作成」クリック時、不要な概要ページ（ステップ0）を経由せず、即座に「ステップ1 基本情報」 7 に遷移させます。これにより、ユーザーが実際のアクション（入力）を開始するまでのクリック数と時間を削減します 2。

### **4.2. 信頼性・データ保持**

* **4.2.1. 入力データの自動保存（ローカルストレージ）:**  
  * **概要:** ウィザード (G-02) での入力中、データは定期的に、または変更が検知されるたびに、ブラウザのローカルストレージに自動保存されます 2。  
  * **UI:** 画面の隅に「自動保存中」 7 のインジケータが表示されます。  
  * **目的:** 仕様書作成は時間がかかる作業であり、ブラウザのクラッシュやネットワークの切断、PCのシャットダウンなどで、長時間かけて入力した内容が失われることを防ぎます 1。  
* **4.2.2. 作業のシームレスな再開:**  
  * **概要:** ユーザーが「編集中」の仕様書を再度開いた際、またはウィザード画面をリロードした際、ローカルストレージに保存されたデータを自動的に読み込み、前回終了時のステップと入力内容を完全に復元します 2。

### **4.3. 互換性・エクスポート**

* **4.3.1. PDFエクスポートの可読性・互換性:**  
  * **概要:** 生成されるPDFファイルは、主要なPDFビューア（Acrobat Reader, 主要ブラウザのビューア）でレイアウト崩れなく表示されること。また、日本語フォントが適切に埋め込まれ、文字化けしないことを保証します 2。  
* **4.3.2. Wordエクスポートの編集互換性:**  
  * **概要:** 生成される.docxファイルは、Microsoft Word（Windows, Mac）およびGoogle Docsで開くことができ、テキストの編集、「変更履歴」機能、「コメント」機能が正常に動作することを保証します 2。  
* **4.3.3. Markdownエクスポートの可読性（Diff-Friendly）:**  
  * **概要:** 生成される.mdファイルは、CommonMark仕様に準拠すること。仕様書の各項目と内容が、Gitの差分表示（diff）で変更箇所が明確に識別しやすいように、適切に改行されたクリーンな形式で出力されます 2。

### **4.4. セキュリティ・認証**

* **4.4.1. ユーザー認証（推測）:**  
  * **概要:** 「自分が作成・管理している全ての仕様書」 1 という要件は、ユーザーの識別が前提となっているため、アプリケーションはユーザー認証（ログイン・ログアウト）機能を備える必要があります 2。  
* **4.4.2. ロールベース・アクセス・コントロール (RBAC)（推測）:**  
  * **概要:** 「仕様書作成者」と「仕様書管理者」の権限を分離し、システム設定（スキーマ）の完全性を守るため、システムは少なくとも2つのロール（「作成者」「管理者」）を持つ必要があります 2。  
  * **実装:** 「作成者」ロールのユーザーには、トップページ 6 の「設定」ボタンが非表示であるか、無効化される必要があります。

---

## **5\. 画面に関する要件**

### **5.1. 画面構成の概要**

本アプリケーションは、主に以下の4つの画面（ビュー）で構成されます。ユーザーのロール（1.4.参照）によって、アクセス可能な画面が異なります。

* **G-01: トップページ（ダッシュボード）:** 全ユーザーの起点。仕様書一覧を表示し、各機能（作成、編集、詳細、設定）へのハブとなる画面。  
* **G-02: 仕様書作成ウィザード:** 「仕様書作成者」が新規作成または編集中に利用する、ステップ形式の入力画面コンテナ。  
* **G-03: 仕様書詳細情報画面:** 「仕様書作成者」が保存済みの仕様書を参照・エクスポートするために利用する画面。  
* **G-04: スキーマ設定画面:** 「仕様書管理者」のみがアクセス可能な、ウィザード (G-02) の内容を定義・変更するための管理画面。

### **5.2. 主要画面の定義**

仕様書作成支援アプリ\_要件定義書 2 に基づき、主要な画面を以下に定義します。

| 画面ID | 画面名 | 目的 | 関連UIイメージ資料 |
| :---- | :---- | :---- | :---- |
| **G-01** | **トップページ（ダッシュボード）** | ユーザーが自身に関連する仕様書を一覧し、管理（新規作成、編集、参照）するためのエントリーポイントを提供する。 | 仕様書作成Webアプリ-1-トップページ.pdf 6 |
| **G-02** | **仕様書作成ウィザード（共通コンテナ）** | 複雑な仕様書項目をステップ・バイ・ステップの形式で入力させ、作業を小さなカテゴリに分割して漏れなく入力を進めさせる。 | 仕様書作成Webアプリ-4.1-基本情報画面.pdf 7 仕様書作成Webアプリ-4.6-仕様確認と保存画面.pdf 10 |
| **G-03** | **仕様書詳細情報画面** | 「保存済み」の仕様書の概要を素早く確認し、エクスポートや編集のアクションを開始する。 | 仕様書作成Webアプリ-3-仕様書詳細情報画面.pdf 8 |
| **G-04** | **スキーマ設定画面** | 組織の業務プロセスに合わせて、仕様書作成の入力フロー（ウィザードのステップ）と入力項目を定義する。 | （UIイメージ提供なし。1 にて機能が定義） |

### **5.3. UIイメージ（参照）**

各画面の具体的なレイアウト、コンポーネント、および視覚的デザインの詳細については、以下のUIイメージ資料群を参照してください。

* **\[資料\]** 仕様書作成Webアプリ-1-トップページ.pdf 6  
* **\[資料\]** 仕様書作成Webアプリ-3-仕様書詳細情報画面.pdf 8  
* **\[資料\]** 仕様書作成Webアプリ-4.1-基本情報画面.pdf 7  
* **\[資料\]** 仕様書作成Webアプリ-4.6-仕様確認と保存画面.pdf 10

---

## **6\. 基本設計**

本セクションでは、上記までの要件を実現するための、システムの技術的な基本設計（アーキテクチャ、データモデル、主要プロセス）を定義します。

### **6.1. システム構成**

#### **6.1.1. システムコンポーネント図（参照）**

システムの全体的なコンポーネント構成、および各コンポーネント間の関係性は、以下の資料に定義されています。

* **\[資料\]** spec\_manager\_system\_diagram.md 4

#### **6.1.2. 主要コンポーネントの役割**

spec\_manager\_system\_diagram.md 4 に基づき、主要コンポーネントの役割と責務を以下に定義します。

* **ユーザー (Actors):**  
  * **仕様書作成者 (Creator):** インスタンス層のデータを操作します。  
  * **仕様書管理者 (Admin):** スキーマ層のデータを操作します。  
* **クライアントサイド (Webブラウザ):**  
  * **フロントエンド (SPA):** UIの動的生成、APIリクエスト送信、およびローカルストレージへの自動保存ロジックを実行するシングルページアプリケーション (SPA) です。  
  * **ローカルストレージ (LocalStorage):** 非機能要件 (4.2.) を実現する中核コンポーネント。ウィザード (G-02) の入力データを一時的に保持し、データ消失防止とシームレスな復元を実現します。  
* **サーバーサイド:**  
  * **バックエンドAPI (Web Server):** ビジネスロジック（バリデーション、バージョン管理）、DB永続化、ファイル（PDF/Word/MD）生成を実行します。  
  * **データベース (RDBMS):** データを永続化します。本アプリの設計思想 (1.2.) に基づき、論理的に2つの層に分離されます。  
    * **スキーマ層 (dbSchema):** 「型」の定義（Schema, Schema\_Category, Schema\_Field）を格納します。  
    * **インスタンス層 (dbInstance):** 「値」のデータ（Specification, Specification\_Content, Deliverable, User 等）を格納します。

システム構成図 4 では、Frontend と LocalStorage 間に「読み書き \[自動保存/復元\]」の関係が定義されていますが、Backend と LocalStorage の間には意図的に接続が定義されていません。これは、非機能要件 2 で定義された「自動保存」が、サーバーリソースを一切消費しない、純粋なクライアントサイドの処理として設計されていることを明確に示しています。これにより、ユーザーはネットワーク遅延のない高速な入力体験を得ると同時に、サーバー負荷が劇的に軽減されます。

### **6.2. データモデル設計**

#### **6.2.1. 設計思想：メタモデル・アーキテクチャ**

本システムのデータモデル設計は、1.2.で述べた**メタモデル・アーキテクチャ**に基づいています 3。

この設計により、管理者が Schema\_Field テーブルに新しい項目（例：「担当部署」）を追加すると、アプリケーションは（コードの変更なしに）自動的にウィザード (G-02) に「担当部署」の入力フィールドを生成し、確認画面 (G-03) にその項目を表示し、Specification\_Content テーブルにその値を保存できるようになります。

データモデルの分析 3 から、データ格納戦略は純粋なEAV（Entity-Attribute-Value）パターン*ではない*、ハイブリッド型であることがわかります。

* **ハイブリッド型データ格納:**  
  * 「件名」や「調達の目的」のような単純なフィールドは、Specification\_Content (EAV) に value として格納されます。  
  * しかし、「納品物」 1 や「業務タスク」 1 のような構造化された（例：「名称」「個数」「説明」を持つ）1対多のリスト項目は、Deliverable や Business\_Task といった\*\*独立したサブエンティティ（テーブル）\*\*としてモデル化されています。  
  * この設計判断の根拠は、UIのパフォーマンスにあります。UI 8 には「業務数: 1件」という集計値が表示されています。この集計（SELECT COUNT(\*)）は、独立した Business\_Task テーブルに対して実行するのが最も高速です。もしEAVテーブル内のJSONBフィールドに格納すると、集計クエリが非現実的なほど遅くなるため、このハイブリッド型（EAV \+ 伝統的リレーショナル）の設計が採用されました。  
* **非正規化によるパフォーマンス最適化:**  
  * データモデル 3 は、Specification テーブルに title カラムを定義しています。  
  * しかし、「件名 (Title)」は、Schema\_Field で定義され、Specification\_Content (EAV) に格納されるべき動的データでもあります。  
  * この重複（非正規化）は意図的なものです。トップページ (G-016) の一覧表示では、多数の仕様書の「件名」を一度に表示する必要があります。もし title カラムがなければ、一覧表示のたびに Specification テーブルと巨大な Specification\_Content テーブルを JOIN し、"件名" に該当する行を探すという、非常に高コストなクエリが必要になります。  
  * したがって、Specification.title カラムを保持し、保存時 (6.3.3.参照) にEAVテーブルから値がコピーされます。これにより、ダッシュボード (G-01) の表示パフォーマンスを劇的に向上させています。

#### **6.2.2. 主要エンティティの役割**

詳細なER図および属性リストは \[資料: 仕様書作成アプリ データモデル生成 3\] を参照してください。主要エンティティの役割の要約は以下の通りです。

| エンティティ名 | レイヤー | 役割の要約 |
| :---- | :---- | :---- |
| **Schema** | **スキーマ層** | 仕様書テンプレート全体（例：「デフォルトスキーマ」）を定義するマスターエンティティ。 |
| **Schema\_Category** | **スキーマ層** | ウィザードの各ステップ（例：「1. 基本情報」）を定義する。display\_order（表示順序）を持つ。 |
| **Schema\_Field** | **スキーマ層** | 各ステップ内の入力項目（例：「件名」）とその型（テキスト、リスト等）、is\_required（必須）設定を定義する。 |
| **Specification** | **インスタンス層** | 個々の仕様書インスタンスのマスター。status, version, author\_user\_id（作成者）, および非正規化された title を保持する。 |
| **Specification\_Content** | **インスタンス層** | EAVパターンに基づき、Schema\_Fieldで定義された単純な項目への「値」を格納する。（例：field\_id='件名', value='...'） |
| **Deliverable, Business\_Task 等** | **インスタンス層** | 1対多の動的リスト項目（納品物、業務タスク等）の構造化データを格納する。（ハイブリッド設計） |
| **User, Role** | **インスタンス層** | ユーザー認証およびRBAC（1.4.参照）を実現するためのエンティティ。 |

### **6.3. プロセス設計（シーケンス）**

システムの根幹をなす主要なプロセスフローの設計を、シーケンス図 5 に基づき定義します。詳細なフローは \[資料: 仕様書作成支援アプリ シーケンス図 5\] を参照してください。

#### **6.3.1. プロセス1：動的フォーム生成シーケンス**

* **トリガー:** ユーザーがウィザード画面 (G-02) にアクセスする。  
* フロー 5:  
  1. Frontend $\\to$ Backend: GET /api/schema/ （動的フォーム定義を要求）  
  2. Backend $\\to$ db(Schema): Schema\_Category と Schema\_Field を display\_order でソートしてクエリ。  
  3. db(Schema) $\\to$ Backend: スキーマ定義（JSON）を返却。  
  4. Backend $\\to$ Frontend: スキーマJSONを返却。  
  5. Frontend: 受け取ったJSONに基づき、ウィザードの進捗バー、ステップ、および各入力フォームを\*\*動的に構築（レンダリング）\*\*する。

#### **6.3.2. プロセス2：入力データの自動保存・復元シーケンス**

* **トリガーA（自動保存）:** ユーザーがウィザード (G-02) のフォームに入力する。  
* フローA 5:  
  1. Creator $\\to$ Frontend: フォーム入力イベント（例：キータイプ）。  
  2. Frontend: 内部状態(state)を更新。  
  3. Frontend: （パフォーマンスのため debounce/throttle 処理を挟み）  
  4. Frontend $\\to$ LocalStorage: setItem('wizard\_data\_' \+ {id},...) を実行し、入力内容をブラウザに保存。  
  5. Frontend: 「自動保存中」インジケータを表示。  
* **トリガーB（復元）:** ユーザーが「編集中」の仕様書を開く（G-02 画面ロード時）。  
* フローB 5:  
  1. Frontend: 画面ロード時、プロセス1 (6.3.1.) と**並行して (par)** 実行。  
  2. Frontend $\\to$ LocalStorage: getItem('wizard\_data\_' \+ {id}) を実行。  
  3. LocalStorage $\\to$ Frontend: 保存済みデータ（JSON）または null を返却。  
  4. Frontend: 取得したデータを内部状態(state)に復元し、プロセス1で構築された動的フォームに値を埋め込む。

#### **6.3.3. プロセス3：最終保存トランザクションシーケンス**

* **トリガー:** ユーザーがウィザードのステップ6 10 で「仕様書を保存する」ボタンをクリックする。  
* フロー 5:  
  1. Creator $\\to$ Frontend: ボタンクリック。  
  2. Frontend $\\to$ LocalStorage: getItem(...) で最終データ（Payload JSON）を取得。  
  3. Frontend $\\to$ Backend: PUT /api/specifications/{id} （Payload JSON を送信）  
  4. バリデーションとロジック決定 (Backend内部):  
     a. Backend $\\to$ db(Schema): この仕様書のスキーマ（is\_required フラグ等）を取得。  
     b. Backend: 受け取ったPayloadとスキーマを検証し、必須項目がすべて入力済みか判断。  
     c. Backend: 3.3.4.のロジックに基づき、version（メジャー/マイナー）と status（保存済み/編集中）を決定する。  
  5. データベース永続化 (Backend $\\to$ db(Instance)):  
     a. Backend $\\to$ db(Instance): BEGIN TRANSACTION  
     b. Backend $\\to$ db(Instance): DELETE FROM Specification\_Content WHERE specification\_id \= {id}  
     c. Backend $\\to$ db(Instance): DELETE FROM Deliverable WHERE specification\_id \= {id}  
     d. Backend $\\to$ db(Instance): DELETE FROM Business\_Task WHERE specification\_id \= {id} （その他すべての1:Nサブエンティティも同様にDELETE）  
     e. Backend $\\to$ db(Instance): INSERT INTO Specification\_Content... （PayloadのEAVデータを挿入）  
     f. Backend $\\to$ db(Instance): INSERT INTO Deliverable... （Payloadの納品物リストを挿入）  
     g. Backend $\\to$ db(Instance): INSERT INTO Business\_Task... （Payloadの業務タスクリストを挿入）  
     h. Backend $\\to$ db(Instance): UPDATE Specification SET version=..., status=..., title=... WHERE id \= {id} （マスターレコードを更新。title の非正規化 (6.2.1.) がここで行われる）  
     i. Backend $\\to$ db(Instance): COMMIT TRANSACTION  
  6. クリーンアップ:  
     a. Backend $\\to$ Frontend: 200 OK  
     b. Frontend $\\to$ LocalStorage: removeItem('wizard\_data\_' \+ {id}) （ローカルのドラフトをクリア）  
     c. Frontend: ユーザーをトップページ (G-01) にリダイレクトする。

この「DELETE & INSERT」パターン 5 は、変更箇所のみを更新（パッチ）するよりも実装が単純ですが、保存操作が常に完全な書き換え（Overwrite）となることを意味します。このため、データベーストランザクション（特にCOMMITとROLLBACK）の堅牢な実装が、データ整合性を担保する上で**絶対的に不可欠**です。トランザクションの途中で失敗した場合、データがすべて削除された状態（DELETE のみ完了）で停止することを確実に防ぐ必要があります。

#### **引用文献**

1. 仕様書作成支援アプリ\_ユーザーストーリー分析  
2. 仕様書作成支援アプリ\_要件定義書  
3. 仕様書作成アプリ データモデル生成  
4. spec\_manager\_system\_diagram.md  
5. 仕様書作成支援アプリ シーケンス図  
6. 仕様書作成Webアプリ-1-トップページ.pdf  
7. 仕様書作成Webアプリ-4.1-基本情報画面.pdf  
8. 仕様書作成Webアプリ-3-仕様書詳細情報画面.pdf  
9. 仕様書作成支援アプリ要件定義, [https://drive.google.com/open?id=1znYwh4EhDkpkJvwA3QBWVJy5LJjkdoK9d7oB9qb8aoM](https://drive.google.com/open?id=1znYwh4EhDkpkJvwA3QBWVJy5LJjkdoK9d7oB9qb8aoM)  
10. 仕様書作成Webアプリ-4.6-仕様確認と保存画面.pdf
